#summary OpenPGM : C Reference : pgm_transport_recvmsgv()
#labels Phase-Implementation

_Function_
=== Declaration ===
<pre>
#include <pgm/pgm.h>

[http://library.gnome.org/devel/glib/stable/glib-Basic-Types.html#gssize gssize] *pgm_transport_recvmsgv* (
	[OpenPgmCReferencePgmTransportT pgm_transport_t]`*`      transport,
	[OpenPgmCReferencePgmMsgvT pgm_msgv_t]`*` const     msgv,
	[http://library.gnome.org/devel/glib/stable/glib-Basic-Types.html#gsize gsize]                 count,
	int                   flags
);
</pre>

=== Purpose ===
Receive a vector of Application Protocol Domain Unit's (APDUs) from the transport.

=== Remarks ===
The PGM protocol is bi-directional, even send-only applications need to process incoming requests for retransmission (NAKs) and other packet types.  The synchronous API suite provides low level access to the raw events driving the protocol in order to accelerate performance in high message rate environments.

<tt>pgm_transport_recvmsgv()</tt> fills a vector of <tt>pgm_msgv_t</tt> structures with a scatter/gather vector of buffers directly from the receive window.  The vector size is governed by IOV_MAX, on Linux is 1024, therefore up to 1024 TPDUs or 1024 messages may be returned, whichever is the lowest.  Using the maximum size is not always recommended as time processing the received messages might cause an incoming buffer overrun.

Memory is returned to the receive window on the next call or transport destruction.

Unrecoverable data loss will cause the function to immediately return with <tt>errno</tt> set to <tt>ECONNRESET</tt>.  If <tt>[OpenPgmCReferencePgmTransportSetCloseOnFailure pgm_transport_set_close_on_failure()]</tt> is called with <tt>FALSE</tt> (the default mode) processing can continue with subsequent calls to <tt>pgm_transport_recvmsgv()</tt>, if <tt>TRUE</tt> then the transport will be closed and subsequent calls will return <tt>ENOTCONN</tt>.

It is valid to send and receive zero length PGM packets.

=== Parameters ===

<table border="1" cellpadding="5" cellspacing="0">
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
<tr>
<td><tt>transport</tt></td>
<td>The PGM transport object.</td>
</tr><tr>
<td><tt>msgv</tt></td>
<td>Message vector of TPDU vectors.</td>
</tr><tr>
<td><tt>count</tt></td>
<td>Elements in <tt>msgv</tt>.</td>
</tr><tr>
<td><tt>flags</tt></td>
<td>Bitwise OR of zero or more flags: <tt>MSG_DONTWAIT</tt> enabling non-blocking operation.</td>
</tr>
</table>


=== Return Value ===
On success, returns the number of data bytes read, or -1 if an error occurred and <tt>errno</tt> appropriately set.

=== Errors ===
<dl><dt><tt>EAGAIN</tt></dt><dd>The socket is marked non-blocking and the receive operation would block.
</dd><dt><tt>ECONNRESET</tt></dt><dd>Unrecoverable data loss was detected.
</dd><dt><tt>EINTR</tt></dt><dd>The receive was interrupted by delivery of a signal before any data were available.
</dd><dt><tt>ENOMEM</tt></dt><dd>Unable to allocate memory for internal tables.
</dd><dt><tt>ENOTCONN</tt></dt><dd>The transport is closed.
</dd></dl>

=== Example ===
Read a maximum size vector from a transport.

{{{
 gsize iov_max = sysconf( SC_IOV_MAX );
 pgm_msgv_t msgv[iov_max];
 gssize bytes_read = pgm_transport_recvmsgv (transport, msgv, iov_max, MSG_DONTWAIT);
}}}

Display error details on unrecoverable error. 

{{{
 pgm_msgv_t msgv[10];
 gssize bytes_read = pgm_transport_recvmsgv (transport, msgv, iov_max, MSG_DONTWAIT);
 if (-1 == len && ECONNRESET == errno) {
  pgm_sock_err_t* pgm_sock_err = (pgm_sock_err_t*)msgv[0].msgv_iov->iov_base;
  g_warning ("pgm socket lost %" G_GUINT32_FORMAT " packets detected from %s",
             pgm_sock_err->lost_count,
             pgm_print_tsi(&pgm_sock_err->tsi));
 }
}}}

=== See Also ===
  * <tt>[OpenPgmCReferencePgmTransportT pgm_transport_t]</tt><br>
  * <tt>[OpenPgmCReferencePgmTransportRecv pgm_transport_recv()]</tt><br>
  * <tt>[OpenPgmCReferencePgmTransportCreate pgm_transport_create()]</tt><br>
  * [OpenPgmCReferenceTransport Transport] in OpenPGM C Reference.
