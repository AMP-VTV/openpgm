OpenPGM C programs require system capabilities from this list in order to function.

__NOTOC__
<table border="1" cellpadding="5" cellspacing="0">
<tr>
<th>System Capability</th>
<th>Description</th>
</tr>
<tr>
<td colspan="2"><h3>Communications and Events</h3></td>
</tr><tr>
<td><tt>CAP_NET_RAW</tt></td>
<td>To create raw sockets required for the PGM protocol.</td>
</tr><tr>
<td><tt>CAP_SYS_NICE</tt></td>
<td>To set real time thread scheduling and high thread priority for processing incoming messages and high resolution timing.</td>
</tr><tr>
<td colspan="2"><h3>Real-time Clock*</h3></td>
</tr><tr>
<td>access to <tt>/dev/rtc</tt></td>
<td>For TSC calibration with the hardware real-time clock access to the <tt>rtc</tt> device can be enabled by adding the user to the real-time Unix group, on Ubuntu this is called <tt>audio</tt>.</td>
</tr>
</table>

'''* Clock selection''' is specified by two system environment variables <tt>PGM_TIMER</tt> governing how to get the current time, and <tt>PGM_SLEEP</tt> governing how to wait for an interval of time.


=== Clock Selection ===
Kernel timer resolution is in a period of change, kernels can be found with standard resolutions of 1-4ms, with high resolution timers providing microsecond to nanosecond resolution.  <tt>[http://en.wikipedia.org/wiki/Rdtsc RDTSC]</tt> is a very cheap mechanism for applications to get the current time in high resolution, however many early generation AMD  and Intel processors suffer from drift between each core.

Particularly prone to error are [http://en.wikipedia.org/wiki/Hyperthread Hyperthread] based processors from Intel, it is highly recommended to disable hyperthreading on all processors wishing to run high speed PGM based messaging.

Older kernels calculate the current time of day based off various sources to provide an accurate, stable, and monotonic source to applications.  Theses calculations are not cheap and historically many applications have been re-engineered to minimise the calls to functions like <tt>gettimeofday()</tt> due to their overhead, using <tt>RDTSC</tt> this is no longer necessary.

The RTC device <tt>/dev/rtc</tt> cannot be shared between multiple applications, it is therefore necessary to use a lower resolution time source or take the processing overhead of polling TSC.

On Linux TSC is calibrated using the details provided by the kernel in <tt>/proc/cpuinfo</tt> which is ratio calculated at boot time.  By default TSC will be calibrated by the method defined by <tt>PGM_SLEEP</tt>, and either value can be overridden by defining <tt>RDTSC_FREQUENCY</tt>.


<table border="1" cellpadding="5" cellspacing="0">
<tr>
<th>Environment Setting</th>
<th>Description</th>
</tr>
<tr>
<td colspan="2"><h3>PGM_TIMER</h3></td>
</tr><tr>
<td><tt>CLOCK_GETTIME</tt></td>
<td>Use <tt>clock_gettime (CLOCK_MONOTONIC, tp)</tt>, see <tt>CLOCK_GETRES(3)</tt> for further details.</td>
</tr><tr>
<td><tt>FTIME</tt></td>
<td>Use <tt>ftime (tp)</tt>, see <tt>FTIME(3)</tt> for further details.</td>
</tr><tr>
<td><tt>RTC</tt></td>
<td>Read from <tt>/dev/rtc</tt> for current time, a 8192 Hz timer providing 122us resolution.</td>
</tr><tr>
<td><tt>TSC</tt></td>
<td>Call RDTSC and normalize with a RTC calibrated count of core ticks.</td>
</tr><tr>
<td><tt>GETTIMEOFDAY</tt>*</td>
<td>Use <tt>gettimeofday (tv, NULL)</tt>, see <tt>GETTIMEOFDAY(2)</tt> for further details.</td>
</tr><tr>
<td colspan="2"><h3>PGM_SLEEP</h3></td>
</tr><tr>
<td><tt>CLOCK_NANOSLEEP</tt></td>
<td>Use <tt>clock_nanosleep (clk_id, TIMER_ABSTIME, tp, NULL)</tt>, see <tt>CLOCK_NANOSLEEP(2)</tt> for further details.</td>
</tr><tr>
<td><tt>NANO_SLEEP</tt></td>
<td>Use <tt>nanosleep (tp, rem)</tt>, see <tt>NANOSLEEP(2)</tt> for further details.</td>
</tr><tr>
<td><tt>RTC</tt></td>
<td>Read interrupts from <tt>/dev/rtc</tt> until requested time has elapsed.</td>
</tr><tr>
<td><tt>TSC</tt></td>
<td>Repeatedly call <tt>RDTSC</tt> interleaving with [http://library.gnome.org/devel/glib/stable/glib-Threads.html#g-thread-yield g_thread_yield()] to allow other threads to execute.</td>
</tr><tr>
<td><tt>USLEEP</tt>* or <tt>MICROSLEEP</tt></td>
<td>Use <tt>usleep (usec)</tt>, see <tt>USLEEP(3)</tt> for further details.</td>
</tr>
</table>

* Default settings.

