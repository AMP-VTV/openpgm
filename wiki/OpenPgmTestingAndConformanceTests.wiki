#summary Tests
#labels Phase-QA

Test numbers as per the referring section in the PGM draft with alphabetical suffix for multiple matching tests.

=== 3.6.2.1.a. Sending ODATA packet ===
<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/odata.pl odata.pl]</tt>

</dd><dt>Overview</dt><dd>Send one data packet from the application and confirm delivery on the network.

</dd><dt>Pseudo code</dt><dd>
<pre>
 app: create transport
 app: send "ringo" 
 mon: wait for ODATA: "ringo"
</pre>
</dd></dl>

=== 5.1.1.a. ODATA sequencing ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/odata_number.pl odata_number.pl]</tt>

</dd><dt>Overview</dt><dd>Send 1,000 data packets and verify sending order is same as received order.

</dd><dt>Pseudo code</dt><dd>
<pre>
 app: create transport
 for (''i'' = 1..1000) {
   app: send ''i''
   mon: wait for ODATA: ''i''
 }
</pre>
</dd></dl>

=== 5.1.1.b. Maximum Cumulative Transmit Rate ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/odata_rate.pl odata_rate.pl]</tt>

</dd><dt>Overview</dt><dd>Set a low TXW_MAX_RTE (1KBps), send 50 data packets and verify received data rate.

</dd><dt>Pseudo code</dt><dd>
<pre>
 app: set TXW_MAX_RTE
 app: create transport
 for (1..50) {
   app: send "ringo"
   mon: wait for ODATA
   ''bytes'' += ODATA packet size
 }
 ''rate'' = ''bytes'' / elapsed time
</pre>
</dd></dl>

=== 5.1.4.a. Ambient SPMs ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/spm.pl spm.pl]</tt>

</dd><dt>Overview</dt><dd>Create a transport and wait for SPM announcement on the network.

</dd><dt>Pseudo code</dt><dd>
<pre>
 app: create transport
 mon: wait for SPM
</pre>
</dd></dl>

=== 5.1.4.b. Ambient SPMs interleaved with ODATA ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/ambient_spm.pl ambient_spm.pl]</tt>

</dd><dt>Overview</dt><dd>Send a stream of data packets with interval less than the minimum SPM heartbeat interval, look for an ambient SPM broadcast.

</dd><dt>Remarks</dt><dd>Highly dependent on PGM parameters, data packets need to be published with greater frequency than the minimum SPM heartbeat interval.  Current configuration is publishing every 50ms which should support heartbeat intervals at 100ms and above.

</dd><dt>Pseudo code</dt><dd>
<pre>
 app: create transport
 fork --------------------------------> /`*` child process `*`/
 mon: wait for odata                    for (;;) {
 mon: wait for spm                        app: send "ringo"
                                        }
</pre>
</dd></dl>

=== 5.1.5.a. Heartbeat SPMs ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/heartbeat_spm.pl heartbeat_spm.pl]</tt>

</dd><dt>Overview</dt><dd>Look for SPMs shortly following an ODATA packet.

</dd><dt>Remarks</dt><dd>Highly dependent on PGM parameters, currently looking for four consecutive heartbeat SPMs less than 1000ms apart.

</dd><dt>Pseudo code</dt><dd>
<pre>
 app: create transport
 app: send "ringo"
 mon: wait for ODATA
 for (1..4) { 
   mon: wait for SPM
 }
</pre>
</dd></dl>

=== 5.2.a. Negative Acknowledgment Confirmation ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/ncf.pl ncf.pl]</tt>

</dd><dt>Overview</dt><dd>Send a sequence of data packets from the application, then request re-transmission of one of the packets and wait for a matching NCF packet.

</dd><dt>Pseudo code</dt><dd>
<pre>
 sim: create transport
 app: create transport
 app: send "ringo"              /`*` sequence number: #1 `*`/
 app: send "ichigo"                              /`*` #2 `*`/
 app: send "momo"                                /`*` #3 `*`/
 mon: wait for ODATA: #1, "ringo"
 mon: wait for ODATA: #2, "ichigo"
 mon: wait for ODATA: #3, "momo"
 sim: send NAK for #2                 /`*` ichigo `*`/
 mon: wait for NCF: #2
</pre>
</dd></dl>

=== 5.3.a. Repairs ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/nak.pl nak.pl]</tt>

</dd><dt>Overview</dt><dd>Send a sequence of data packets from the application, then request re-transmission of one of the packets and wait for a matching RDATA packet.

</dd><dt>Pseudo code</dt><dd>
<pre>
 sim: create transport
 app: create transport
 app: send "ringo"              /`*` sequence number: #1 `*`/
 app: send "ichigo"                              /`*` #2 `*`/
 app: send "momo"                                /`*` #3 `*`/
 mon: wait for ODATA: #1, "ringo"
 mon: wait for ODATA: #2, "ichigo"
 mon: wait for ODATA: #3, "momo"
 sim: send NAK for #2                 /`*` ichigo `*`/
 mon: wait for RDATA: #2, "ichigo"
</pre>
</dd></dl>

=== 6.1.a. Data Reception by ODATA ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/odata_reception.pl odata_reception.pl]</tt>

</dd><dt>Overview</dt><dd>Initiate a PGM session with an ODATA and verify with following ODATA.

</dd><dt>Pseudo code</dt><dd>
<pre>
 app: create transport
 app: listen on transport
 sim: create fake transport
 sim: publish ODATA sqn 90,000
 app: wait for data
 sim: verify no NAKs are generated from app
 sim: publish ODATA sqn 90,001
 app: wait for data
</pre>
</dd></dl>

=== 6.1.b. Data Reception by RDATA ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/rdata_reception.pl rdata_reception.pl]</tt>

</dd><dt>Overview</dt><dd>Initiate a PGM session with a RDATA packet and verify with following ODATA.

</dd><dt>Pseudo code</dt><dd>
<pre>
 app: create transport
 app: listen on transport
 sim: create fake transport
 sim: publish RDATA sqn 90,000
 app: wait for data
 sim: verify no NAKs are generated from app
 sim: publish ODATA sqn 90,001
 app: wait for data
</pre>
</dd></dl>

=== 6.1.c. Data Reception by SPM ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/spm_reception.pl spm_reception.pl]</tt>

</dd><dt>Overview</dt><dd>Initiate a PGM session with a SPM and verify with matching ODATA.

</dd><dt>Pseudo code</dt><dd>
<pre>
 app: create transport
 app: listen on transport
 sim: create fake transport
 sim: publish SPM txw_trail 90,000
 sim: verify no NAKs are generated from app
 sim: publish ODATA sqn 90,001
 app: wait for data
</pre>
</dd></dl>

=== 6.1.d. Fragmented APDU ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/apdu.pl apdu.pl]</tt>

</dd><dt>Overview</dt><dd>Send a fragmented APDU and confirm reconstruction at the receiver side.

</dd><dt>Pseudo code</dt><dd>
<pre>
 app: create transport
 app: listen on transport
 sim: create transport
 sim: publish 5KiB ODATA message
 app: wait for data
</pre>
</dd></dl>

=== 6.2.a. Out-of-sequence SPMs must be discarded ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/spm_jump.pl spm_jump.pl]</tt>

</dd><dt>Overview</dt><dd>Create a PGM session with an initial SPM, follow with an out-of-sequence SPM and verify no NAKs are generated.

</dd><dt>Pseudo code</dt><dd>
<pre>
 app: create transport
 app: listen on transport
 sim: create fake transport
 sim: publish SPM txw_lead 90,000 SPM sqn 3200
 sim: publish SPM txw_lead 90,005 SPM sqn 20
 sim: verify no NAKs are generated from app
</pre>
</dd></dl>

=== 6.3.a. NAK generation induced by ODATA ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/odata_jump.pl odata_jump.pl]</tt>

</dd><dt>Overview</dt><dd>Create a PGM session with an initial ODATA packet, follow with an ODATA with a jumped sequence number.

</dd><dt>Pseudo code</dt><dd>
<pre>
 app: create transport
 app: listen on transport
 sim: create fake transport
 sim: publish ODATA sqn 90,001
 sim: publish ODATA sqn 90,003
 sim: wait for NAK
</pre>
</dd></dl>

=== 6.3.b. NAK generation induced by RDATA ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/rdata_jump.pl rdata_jump.pl]</tt>

</dd><dt>Overview</dt><dd>Create a PGM session with an initial ODATA packet, follow with an RDATA with a jumped sequence number.

</dd><dt>Pseudo code</dt><dd>
<pre>
 app: create transport
 app: listen on transport
 sim: create fake transport
 sim: publish ODATA sqn 90,001
 sim: publish RDATA sqn 90,003
 sim: wait for NAK
</pre>
</dd></dl>

=== 6.3.c. NAK generation induced by SPM ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/spm_jump2.pl spm_jump2.pl]</tt>

</dd><dt>Overview</dt><dd>Create a PGM session with an initial SPM, follow with an in-sequence SPM that indicates the transmit window has advanced.

</dd><dt>Pseudo code</dt><dd>
<pre>
 app: create transport
 app: listen on transport
 sim: create fake transport
 sim: publish SPM txw_lead 90,000 SPM sqn 3200
 sim: publish SPM txw_lead 90,001 SPM sqn 3201
 sim: wait for NAK
</pre>
</dd></dl>

=== 6.3.d. NAK suppression by NCF ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/ncf_suppression.pl ncf_suppression.pl]</tt>

</dd><dt>Overview</dt><dd>Send out-of-sequence ODATA packets to induce a NAK, but follow with a NCF to suppress sending.

</dd><dt>Pseudo code</dt><dd>
<pre>
 app: create transport
 sim: create fake transport
 sim: sent SPM                        /`*` set NLA in app `*`/
 sim: send "ringo"
 app: wait for data
 sim: send "ichigo" with sequence number jump 
 sim: send NCF
 sim: fail if NAK received
</pre>
</dd></dl>

=== 6.3.f. Completion by ODATA ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/odata_completion.pl odata_completion.pl]</tt>

</dd><dt>Overview</dt><dd>Send out-of-sequence ODATA packets to induce a NAK, but follow with a ODATA to complete sequence.

</dd><dt>Pseudo code</dt><dd>
<pre>
 app: create transport
 app: send "nashi"
 mon: wait for ODATA and save TSI
 sim: create fake transport
 sim: sent SPM                        /`*` set NLA in app `*`/
 sim: send "ringo"
 app: wait for data
 sim: send "ichigo" with sequence number jump 
 sim: send ODATA "momo"
 app: wait for data: "momo"
 app: wait for data: "ichigo"
</pre>
</dd></dl>

=== 6.3.g. Completion by RDATA ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/rdata_completion.pl rdata_completion.pl]</tt>

</dd><dt>Overview</dt><dd>Send out-of-sequence ODATA packets to induce a NAK, but follow with a RDATA to complete sequence.

</dd><dt>Pseudo code</dt><dd>
<pre>
 app: create transport
 sim: create fake transport
 sim: sent SPM                        /`*` set NLA in app `*`/
 sim: send "ringo"
 app: wait for data
 sim: send "ichigo" with sequence number jump 
 sim: send RDATA "momo"
 app: wait for data: "momo"
 app: wait for data: "ichigo"
</pre>
</dd></dl>

=== 6.3.h. NAK cancellation by NCF ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/ncf_cancellation.pl ncf_cancellation.pl]</tt>

</dd><dt>Overview</dt><dd>Send out-of-sequence ODATA packets to induce a NAK, wait until NAK is cancelled by NCF retry count.

</dd><dt>Pseudo code</dt><dd>
<pre>
 app: create transport
 sim: create fake transport
 sim: sent SPM                        /`*` set NLA in app `*`/
 sim: send "ringo"
 app: wait for data
 sim: send "ichigo" with sequence number jump 
 fork --------------------------------> /`*` child process `*`/
 app: wait for data                     for (;;) {
                                          sim: wait for NAK
                                        }
</pre>
</dd></dl>

=== 6.3.i. NAK cancellation by DATA ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/nak_cancellation.pl nak_cancellation.pl]</tt>

</dd><dt>Overview</dt><dd>Send out-of-sequence ODATA packets to induce a NAK, wait until NAK is cancelled by DATA retry count.

</dd><dt>Pseudo code</dt><dd>
<pre>
 app: create transport
 sim: create fake transport
 sim: sent SPM                        /`*` set NLA in app `*`/
 sim: send "ringo"
 app: wait for data
 sim: send "ichigo" with sequence number jump 
 fork --------------------------------> /`*` child process `*`/
 app: wait for data                     for (;;) {
                                          sim: wait for NAK
                                          sim: send NCF
                                        }
</pre>
</dd></dl>

== 9.3. NAK List Option - OPT_NAK_LIST ==

<dl><dt>Description</dt><dd>The NAK List Option allows transmission of more than sequence number with a single NAK packet.


=== 9.3.a. Sending RDATA in response to valid NAK List ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/nak_list.pl nak_list.pl]</tt>

</dd><dt>Overview</dt><dd>Send a sequence of data packets from the application, then request re-transmission of a list of packets and wait for a matching sequence of RDATA packets.

</dd><dt>Pseudo code</dt><dd>
<pre>
 sim: create fake transport
 app: create transport
 app: send "ringo"              /`*` sequence number: #1 `*`/
 app: send "ichigo"                              /`*` #2 `*`/
 app: send "momo"                                /`*` #3 `*`/
 mon: wait for ODATA: #1, "ringo"
 mon: wait for ODATA: #2, "ichigo"
 mon: wait for ODATA: #3, "momo"
 sim: send NAK list for #1, #2, #3               /`*` all packets `*`/
 mon: wait for RDATA: #1, "ringo"
 mon: wait for RDATA: #2, "ichigo"
 mon: wait for RDATA: #3, "momo"
</pre>
</dd></dl>

=== 9.3.b. Sending NCF in response to valid NAK List ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/ncf_list.pl ncf_list.pl]</tt>

</dd><dt>Overview</dt><dd>Send a sequence of data packets from the application, then request re-transmission of a list of packets and wait for a matching NCF list packet.

</dd><dt>Pseudo code</dt><dd>
<pre>
 sim: create fake transport
 app: create transport
 app: send "ringo"              /`*` sequence number: #1 `*`/
 app: send "ichigo"                              /`*` #2 `*`/
 app: send "momo"                                /`*` #3 `*`/
 mon: wait for ODATA: #1, "ringo"
 mon: wait for ODATA: #2, "ichigo"
 mon: wait for ODATA: #3, "momo"
 sim: send NAK list for #1, #2, #3               /`*` all packets `*`/
 mon: wait for NCF list: #1, #2, #3
</pre>
</dd></dl>

== 13. Appendix C - SPM Requests ==

<dl><dt>Description</dt><dd>SPM Requests (SPMRs) MAY be used to solicit an SPM from a source in a non-implosive way.


=== 13.3.1.a SPM Request on DATA opened session ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/spmr_from_odata.pl spmr_from_odata.pl]</tt>

</dd><dt>Overview</dt><dd>Send a ODATA packet to lead a new session, wait for SPM Request from test application.

</dd><dt>Pseudo code</dt><dd>
<pre>
 sim: create fake transport
 app: create transport
 sim: send "ringo"
 mon: wait for SPMR
</pre>
</dd></dl>

=== 13.3.1.b SPM broadcast on SPM Request ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/spmr.pl spmr.pl]</tt>

</dd><dt>Overview</dt><dd>Send a SPM Request and wait for a matching SPM broadcast.

</dd><dt>Pseudo code</dt><dd>
<pre>
 sim: create fake transport
 app: create transport
 sim: send SPMR
 mon: wait for SPM
</pre>
</dd></dl>

=== 13.3.1.c SPMR suppression by SPMR ===

<dl><dt>Test</dt><dd><tt>[http://code.google.com/p/openpgm/source/browse/#svn/trunk/openpgm/pgm/test/spmr_suppression.pl spmr_suppression.pl]</tt>

</dd><dt>Overview</dt><dd>Induce a SPM Request by ODATA lead new session, suppress SPMR generation by sending a multicast peer SPMR.

</dd><dt>Pseudo code</dt><dd>
<pre>
 sim: create fake transport
 app: create transport
 sim: send "ringo"
 sim: send SPMR
 mon: fail on SPMR
</pre>
</dd></dl>
